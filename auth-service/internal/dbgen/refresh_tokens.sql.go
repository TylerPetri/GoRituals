// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refresh_tokens.sql

package dbgen

import (
	"context"
	"net/netip"
	"time"
)

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
delete from refresh_tokens where expires_at < now()
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredTokens)
	return err
}

const getActiveRefreshTokenByID = `-- name: GetActiveRefreshTokenByID :one
select id, user_id, token_hash, issued_at, expires_at, revoked_at, ua, ip
from refresh_tokens
where id = $1 and revoked_at is null
`

func (q *Queries) GetActiveRefreshTokenByID(ctx context.Context, id int64) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getActiveRefreshTokenByID, id)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.Ua,
		&i.Ip,
	)
	return i, err
}

const getRefreshTokenByHash = `-- name: GetRefreshTokenByHash :one
select id, user_id, token_hash, issued_at, expires_at, revoked_at, ua, ip
from refresh_tokens where token_hash = $1
`

func (q *Queries) GetRefreshTokenByHash(ctx context.Context, tokenHash string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByHash, tokenHash)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.Ua,
		&i.Ip,
	)
	return i, err
}

const insertRefreshToken = `-- name: InsertRefreshToken :one
insert into refresh_tokens (user_id, token_hash, expires_at, ua, ip)
values ($1, $2, $3, $4, $5)
RETURNING id, user_id, token_hash, issued_at, expires_at, revoked_at, ua, ip
`

type InsertRefreshTokenParams struct {
	UserID    int64      `json:"user_id"`
	TokenHash string     `json:"token_hash"`
	ExpiresAt time.Time  `json:"expires_at"`
	Ua        string     `json:"ua"`
	Ip        netip.Addr `json:"ip"`
}

func (q *Queries) InsertRefreshToken(ctx context.Context, arg InsertRefreshTokenParams) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, insertRefreshToken,
		arg.UserID,
		arg.TokenHash,
		arg.ExpiresAt,
		arg.Ua,
		arg.Ip,
	)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.Ua,
		&i.Ip,
	)
	return i, err
}

const lockActiveRefreshTokenByID = `-- name: LockActiveRefreshTokenByID :one
select id, user_id, token_hash, issued_at, expires_at, revoked_at, ua, ip
from refresh_tokens
where id = $1 and revoked_at is null
for update
`

func (q *Queries) LockActiveRefreshTokenByID(ctx context.Context, id int64) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, lockActiveRefreshTokenByID, id)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.Ua,
		&i.Ip,
	)
	return i, err
}

const revokeAllForUser = `-- name: RevokeAllForUser :exec
update refresh_tokens set revoked_at = now() where user_id = $1 and revoked_at is null
`

func (q *Queries) RevokeAllForUser(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, revokeAllForUser, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
update refresh_tokens set revoked_at = now() where id = $1
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, id)
	return err
}

const revokeRefreshTokenByID = `-- name: RevokeRefreshTokenByID :exec
update refresh_tokens set revoked_at = now()
where id = $1 and revoked_at is null
`

func (q *Queries) RevokeRefreshTokenByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, revokeRefreshTokenByID, id)
	return err
}
